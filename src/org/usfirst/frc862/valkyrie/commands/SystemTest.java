// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc862.valkyrie.commands;
import org.usfirst.frc862.util.StatefulCommand;
import org.usfirst.frc862.valkyrie.Constants;
import org.usfirst.frc862.valkyrie.Robot;
import org.usfirst.frc862.valkyrie.RobotMap;

/**
 *
 */
public class SystemTest extends StatefulCommand {
    boolean complete = false;
    private boolean ispressed = false;
    private double encoderStart;
    
    enum States {
        TEST_LEFT_MOTOR1, TEST_LEFT_MOTOR2, TEST_LEFT_MOTOR3,
        TEST_RIGHT_MOTOR1, TEST_RIGHT_MOTOR2, TEST_RIGHT_MOTOR3,
        TEST_WINCH_MOTOR1, TEST_WINCH_MOTOR2,
        
        TEST_COMPRESSOR,
        TEST_UPSHIFT, TEST_DOWNSHIFT, 
        TEST_GEAR_TRAY,
        
        TEST_LEFT_ENCODER, TEST_RIGHT_ENCODER,
        TEST_NAVX,
        
        TEST_FRONT_ULTRASONIC, TEST_LEFT_ULTRASONIC,
        TEST_RIGHT_ULTRASONIC, TEST_REAR_ULTRASONIC,
        
        TEST_GEAR_SENSOR,
        
        TESTS_ARE_DONE;
        
        public States next() {
            // No bounds checking required here, because the last instance overrides
            return values()[ordinal() + 1];
        }
    }
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public SystemTest() {
        super(States.TEST_LEFT_MOTOR1);
        
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shifter);
        requires(Robot.core);
        requires(Robot.winch);
        requires(Robot.gearCollector);
        
        this.setDefaultAction(() -> next());
    }

    // Called just before this Command runs the first time
    protected void initialize() {
        super.initialize();
        Robot.driveTrain.configure_test_mode();
        complete = false;
        state = States.TEST_LEFT_MOTOR1;
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return complete;
    }

    // Called once after isFinished returns true
    protected void end() {
        Robot.driveTrain.configure_follow_modes();
        Robot.driveTrain.stop();
        Robot.gearCollector.retract();
        Robot.shifter.downShift();
        Robot.winch.stop();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        end();
    }

    boolean buttonReleased() {
        if (ispressed  && !Robot.oi.buttonThing.getRawButton(0)) {
            ispressed = false;
            return true;
        } else if (Robot.oi.buttonThing.getRawButton(0)) {
            ispressed = true;
        }
        return false;
    }

    public boolean next() {
        if (buttonReleased()) {
            state = ((States) state).next();
            return true;
        }
        
        return false;
    }
    
    public double nextWithValue(double fValue, double tValue) {
        return next() ? tValue : fValue;
    }
    
    public void testLeftMotor1() {
        RobotMap.driveTrainLeftMotor1.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testLeftMotor2() {
        RobotMap.driveTrainLeftMotor2.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testLeftMotor3() {
        RobotMap.driveTrainLeftMotor3.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor1() {
        RobotMap.driveTrainRightMotor1.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor2() {
        RobotMap.driveTrainRightMotor2.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor3() {
        RobotMap.driveTrainRightMotor3.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }

    public void testWinchMotor1() {
        RobotMap.winchWinchMotor1.set(nextWithValue(Constants.WinchTestPower, 0.0));
    }
    
    public void testWinchMotor2() {
        RobotMap.winchWinchMotor2.set(nextWithValue(Constants.WinchTestPower, 0.0));
    }
    
    public void testCompressor() {
        RobotMap.coreCompressor.setClosedLoopControl(false);
        RobotMap.coreCompressor.enabled();
        if (next()) {
            RobotMap.coreCompressor.setClosedLoopControl(true);            
        }
    }
    
    public void testUpshift() {
        Robot.shifter.upShift();
        next();
    }
    
    public void testDownshift() {
        Robot.shifter.downShift();
        next();
    }
    
    public void testGearTray() {
        Robot.gearCollector.extend();
        if (next()) {
            Robot.gearCollector.retract();
        }
    }
    
    public void testLeftEncoderEnter() {
        encoderStart = Robot.driveTrain.getLeftDistance();
        Robot.driveTrain.set(Constants.MotorTestPower, 0);        
    }
    
    public void testLeftEncoderExit() {
        Robot.driveTrain.stop();        
        double encoderStop = Robot.driveTrain.getLeftDistance();
        // TODO display test results
    }
    
    public void testRightEncoderEnter() {
        encoderStart = Robot.driveTrain.getRightDistance();
        Robot.driveTrain.set(0, Constants.MotorTestPower);        
    }
    
    public void testRightEncoderExit() {
        Robot.driveTrain.stop();        
        double encoderStop = Robot.driveTrain.getRightDistance();
        // TODO display test results
    }
    
    public void testNavx() {
        next();
    }
    
    public void testFrontUltrasonic() {
        next();
    }
    
    public void testLeftUltrasonic() {
        next();
    }
    
    public void testRightUltrasonic() {
        next();
    }
    
    public void testRearUltrasonic() {
        next();
    }
    
    public void testGearSensor() {
        next();
    }
    
    public void testsAreDone() {
        complete = true;
    }
}
