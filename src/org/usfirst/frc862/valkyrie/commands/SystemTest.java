// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc862.valkyrie.commands;
import org.usfirst.frc862.util.StatefulCommand;
import org.usfirst.frc862.valkyrie.Constants;
import org.usfirst.frc862.valkyrie.Robot;
import org.usfirst.frc862.valkyrie.RobotMap;
import org.usfirst.frc862.valkyrie.subsystems.Core.Ultrasonic;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class SystemTest extends StatefulCommand {
    boolean complete = false;
    private boolean ispressed = false;
    private double encoderStart;
    private double startingValue;
    
    enum States {
        TEST_LEFT_MOTOR1, TEST_LEFT_MOTOR2, TEST_LEFT_MOTOR3,
        TEST_RIGHT_MOTOR1, TEST_RIGHT_MOTOR2, TEST_RIGHT_MOTOR3,
        TEST_WINCH_MOTOR1, TEST_WINCH_MOTOR2,
        
        TEST_COMPRESSOR,
        TEST_UPSHIFT, TEST_DOWNSHIFT, 
        TEST_GEAR_TRAY,
        
        TEST_LEFT_ENCODER, TEST_RIGHT_ENCODER,
        TEST_NAVX,
        
        TEST_FRONT_ULTRASONIC, TEST_LEFT_ULTRASONIC,
        TEST_RIGHT_ULTRASONIC, TEST_REAR_ULTRASONIC,
        
        TEST_GEAR_SENSOR,
        
        TESTS_ARE_DONE;
        
        public States next() {
            // No bounds checking required here, because the last instance overrides
            return values()[ordinal() + 1];
        }
    }
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public SystemTest() {
        
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        super(States.TEST_LEFT_MOTOR1);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shifter);
        requires(Robot.core);
        requires(Robot.winch);
        requires(Robot.gearCollector);
        
        this.setDefaultAction(() -> next());
    }

    // Called just before this Command runs the first time
    protected void initialize() {
        super.initialize();
        Robot.driveTrain.configure_test_mode();
        complete = false;
        status("initalized");
        setState(States.TEST_LEFT_MOTOR1);
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return complete;
    }

    @Override
    protected void execute() {
        // TODO Auto-generated method stub
        super.execute();
    }

    // Called once after isFinished returns true
    protected void end() {
        Robot.driveTrain.configure_follow_modes();
        Robot.driveTrain.stop();
        Robot.gearCollector.retract();
        Robot.shifter.downShift();
        Robot.winch.stop();
        RobotMap.coreCompressor.setClosedLoopControl(true);            
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        end();
    }

    boolean buttonReleased() {
        boolean button = Robot.oi.buttonThing.getRawButton(0) || 
                Robot.oi.driverLeft.getRawButton(1) ||
                Robot.oi.driverRight.getRawButton(1);
        if (ispressed && !button) {
            ispressed = false;
            return true;
        } else if (button) {
            ispressed = true;
        }
        
        return false;
    }

    public boolean next() {
        if (buttonReleased()) {
            setState(((States) getState()).next());
            return true;
        }
        
        return false;
    }
    
    public void success() {
        SmartDashboard.putBoolean(getCallingState().toString(), true);
    }
    
    public void fail() {
        SmartDashboard.putBoolean(getCallingState().toString(), false);
    }
    
    public double nextWithValue(double fValue, double tValue) {
        return next() ? tValue : fValue;
    }
    
    public void testLeftMotor1Enter() {
        encoderStart = Robot.driveTrain.getLeftDistance();
    }
    
    public void testLeftMotor1() {
        RobotMap.driveTrainLeftMotor1.set(nextWithValue(Constants.MotorTestPower, 0));
    }
    
    public void testLeftMotor1Exit() {
        if (Math.abs(Robot.driveTrain.getLeftDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testLeftMotor2Enter() {
        encoderStart = Robot.driveTrain.getLeftDistance();
    }
    
    public void testLeftMotor2() {
        RobotMap.driveTrainLeftMotor2.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testLeftMotor2Exit() {
        if (Math.abs(Robot.driveTrain.getLeftDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testLeftMotor3Enter() {
        encoderStart = Robot.driveTrain.getLeftDistance();
    }
    
    public void testLeftMotor3Exit() {
        if (Math.abs(Robot.driveTrain.getLeftDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testLeftMotor3() {
        RobotMap.driveTrainLeftMotor3.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor1Enter() {
        encoderStart = Robot.driveTrain.getRightDistance();
    }
    
    public void testRightMotor1Exit() {
        if (Math.abs(Robot.driveTrain.getRightDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRightMotor1() {
        RobotMap.driveTrainRightMotor1.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor2Enter() {
        encoderStart = Robot.driveTrain.getRightDistance();
    }
    
    public void testRightMotor2Exit() {
        if (Math.abs(Robot.driveTrain.getRightDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRightMotor2() {
        RobotMap.driveTrainRightMotor2.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }
    
    public void testRightMotor3Enter() {
        encoderStart = Robot.driveTrain.getRightDistance();
    }
    
    public void testRightMotor3Exit() {
        if (Math.abs(Robot.driveTrain.getRightDistance() - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRightMotor3() {
        RobotMap.driveTrainRightMotor3.set(nextWithValue(Constants.MotorTestPower, 0.0));
    }

    public void testWinchMotor1Exit() {
        success();
    }
    
    public void testWinchMotor1() {
        RobotMap.winchWinchMotor1.set(nextWithValue(Constants.WinchTestPower, 0.0));
    }
    
    public void testWinchMotor2Exit() {
        success();
    }
    
    public void testWinchMotor2() {
        RobotMap.winchWinchMotor2.set(nextWithValue(Constants.WinchTestPower, 0.0));
    }
    
    public void testCompressor() {
        RobotMap.coreCompressor.setClosedLoopControl(false);
        RobotMap.coreCompressor.enabled();
        if (next()) {
            RobotMap.coreCompressor.setClosedLoopControl(true);            
        }
    }
    
    public void testCompressorExit() {
        success();
    }
    
    public void testUpshift() {
        Robot.shifter.upShift();
        next();
    }
    
    public void testUpshiftExit() {
        success();
    }
    
    public void testDownshift() {
        Robot.shifter.downShift();
        next();
    }
    
    public void testDownshiftExit() {
        success();
    }
    
    public void testGearTray() {
        Robot.gearCollector.extend();
        if (next()) {
            Robot.gearCollector.retract();
        }
    }
    
    public void testGearTrayExit() {
        success();
    }
    
    public void testLeftEncoderEnter() {
        encoderStart = Robot.driveTrain.getLeftDistance();
        Robot.driveTrain.set(Constants.MotorTestPower, 0);        
    }
    
    public void testLeftEncoderExit() {
        Robot.driveTrain.stop();        
        double encoderStop = Robot.driveTrain.getLeftDistance();
        
        if (Math.abs(encoderStop - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRightEncoderEnter() {
        encoderStart = Robot.driveTrain.getRightDistance();
        Robot.driveTrain.set(0, Constants.MotorTestPower);        
    }
    
    public void testRightEncoderExit() {
        Robot.driveTrain.stop();        
        double encoderStop = Robot.driveTrain.getRightDistance();
        
        if (Math.abs(encoderStop - encoderStart) > Constants.MotorTestDistance) {
            success();
        } else {
            fail();
        }
    }
    
    public void testNavxEnter() {
        status("Rotate the robot at least 5 degrees");
        startingValue = Robot.driveTrain.getGyroAngle();
    }
    
    public void testNavxExit() {
        if (Math.abs(Robot.driveTrain.getGyroAngle() - startingValue) > 5) {
            success();
        } else {
            fail();
        }
    }
    
    public void testFrontUltrasonicEnter() {
        startingValue = Robot.core.getUltrasonic(Ultrasonic.Front);
        status("Block the front ultrasonic sensor");
    }
    
    public void testFrontUltrasonicExit() {
        if (Math.abs(startingValue - Robot.core.getUltrasonic(Ultrasonic.Front)) > 2) {
            success();
        } else {
            fail();
        }
    }
    
    public void testLeftUltrasonicEnter() {
        startingValue = Robot.core.getUltrasonic(Ultrasonic.Left);
        status("Block the left ultrasonic sensor");
    }
    
    public void testLeftUltrasonicExit() {
        if (Math.abs(startingValue - Robot.core.getUltrasonic(Ultrasonic.Left)) > 2) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRightUltrasonicEnter() {
        startingValue = Robot.core.getUltrasonic(Ultrasonic.Right);
        status("Block the right ultrasonic sensor");
    }
    
    public void testRightUltrasonicExit() {
        if (Math.abs(startingValue - Robot.core.getUltrasonic(Ultrasonic.Right)) > 2) {
            success();
        } else {
            fail();
        }
    }
    
    public void testRearUltrasonicEnter() {
        startingValue = Robot.core.getUltrasonic(Ultrasonic.Back);
        status("Block the rear ultrasonic sensor");
    }
    
    public void testRearUltrasonicExit() {
        if (Math.abs(startingValue - Robot.core.getUltrasonic(Ultrasonic.Back)) > 2) {
            success();
        } else {
            fail();
        }
    }
    
    public void testGearSensorEnter() {
    }
    
    public void testGearSensorExit() {
    }
    
    public void testsAreDone() {
        status("Tests complete");
        complete = true;
    }

    public void status(String msg) {
        SmartDashboard.putString("System Test Instruction", msg);    
    }
    
    public static void update() {
        SmartDashboard.putString("System Test Instruction", "Run the system test!");
        for (States s : States.values()) {
            SmartDashboard.putBoolean(s.toString(), false);
        }
    }
}
